# 浏览器缓存

缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。

[TOC]

## 缓存位置

内存缓存优先。
对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存使用率高的话，文件优先存储进硬盘

### service worker

Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。
Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

实现缓存：
1. 注册service worker
2. install event =》 缓存需要缓存的文件
3. 在下次请求前拦截请求，并从缓存中读取缓存文件。

### memory cache（内存缓存）

从内存中获取数据。关闭tab页面，则释放内存缓存。
内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：
1、快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。
2、时效性：一旦该进程关闭，则该进程的内存则会清空。

```
<link rel="preloader">
```

### disk cache（硬盘缓存）

比内存缓存慢些。
硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。

### push cache（推送缓存）

它是http2中的内容。

## 缓存策略

由http header控制。

1. 强缓存。只要缓存的数据在有效时间内，则使用缓存中数据。
2. 协商缓存


## 缓存过程分析

浏览器根据响应头确定是否缓存。

```

      浏览器                 浏览器缓存                   server
        |                      |                          |
        |                      |                          |
        |   第一次发起http请求   |                          |
        |--------------------->|                          |
        |                      |                          |
        |                      |                          |
        |   没有缓存结果或标识    |                          |
        |<---------------------|                          |
        |                      |                          |
        |                      |                          |
        |                 发送http请求                      |
        |------------------------------------------------>|
        |                      |                          |
        |                      |                          |
        |                返回数据                           |
        |<------------------------------------------------|
        |                      |                          |
        |                      |                          |
        |   按缓存规则放入缓存中   |                          |
        |--------------------->|                          |
        |                      |                          |
        |                      |                          |
      浏览器                 浏览器缓存                   server

```

## 强缓存

强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control

Expires是http/1.0的产物。
Cache-Control是http/1.1的产物。
Cache-Control的优先级高于Expires。当浏览器不支持Cache-Control时使用Expires.


### Expires

http/1的产物。
需要与Last-modified一起使用。
expires的值是服务设置的。
若修改客户端的本地时间，则expires会受影响。

### Cache-Control

http/1.1的产物。
```
Cache-Control: max-age=300
// 未来300s内使用缓存中的数据。
```
|value|describ||
|-|-|-|
|public|可以被客户端、代理服务器缓存。||
|private|只可以在客户端缓存||
|max-age=30|缓存有效期是30s||
|s-maxage=3|覆盖max-age，只在代理服务器中生效。||
|no-store|不缓存||
|no-cache|保存在缓存中，并且立即失效。下次开始向服务端请求||
|max-state=30|即使缓存过期，在30s也使用缓存。||
|min-fresh=30|希望在30s内获取最新的响应||

## 协商缓存

返回304 、 Not Modified
Last-Modified / Etag

```

      浏览器                 浏览器缓存                   server
        |                      |                          |
        |                      |                          |
        |   第一次发起http请求   |                          |
        |--------------------->|                          |
        |                      |                          |
        |                      |                          |
        |   若缓存失效           |                          |
        |   则返回缓存标识        |                          |
        |<---------------------|                          |
        |                      |                          |
        |                      |                          |
        |         携带该数据的缓存标识，发送http请求            |
        |         (If-Modified-Since)                     |
        |------------------------------------------------>|
        |                      |                          |
        |                      |                          |
        |                304和空响应体                      |
        |<------------------------------------------------|
        |                      |                          |
        |                      |                          |
        |        获取缓存        |                          |
        |--------------------->|                          |
        |                      |                          |
        |                      |                          |
        |   返回该请求的缓存结果   |                          |
        |<---------------------|                          |
        |                      |                          |
        |                      |                          |
      浏览器                 浏览器缓存                   server


      浏览器                 浏览器缓存                   server
        |                      |                          |
        |                      |                          |
        |   第一次发起http请求   |                          |
        |--------------------->|                          |
        |                      |                          |
        |                      |                          |
        |   若缓存失效           |                          |
        |   则返回缓存标识        |                          |
        |<---------------------|                          |
        |                      |                          |
        |                      |                          |
        |         携带该数据的缓存标识，发送http请求            |
        |------------------------------------------------>|
        |                      |                          |
        |                      |                          |
        |                200，该资源                   |
        |<------------------------------------------------|
        |                      |                          |
        |                      |                          |
        |   按缓存规则放入缓存中   |                          |
        |--------------------->|                          |
        |                      |                          |
        |                      |                          |
      浏览器                 浏览器缓存                   server

```

### Last-Modified的弊端

当打开缓存文件时会造成该值被修改。
只能以s计。时间粒度大。

所以在http/1.1时出现了Etag/If-None-Match.

### Etag / If-None-Match

Etag当前资源的惟一标识。由服务器生成。就资源有变化，则重新生成。
1. 在精确度上,Etag优于Last-Modified.
如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。
2. 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
3. 第三在优先级上，服务器校验优先考虑Etag.

## 缓存机制

强缓存优先于协商缓存。
如果什么缓存策略都没设置，那么浏览器会怎么处理？浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。

## 实际应用场景

1. 对于频繁变动的资源。使用`Cache-Control: no-cache`
2. 不常变化的资源。使用`Cache-Control: max-age=31536000` // 1year
  如jquery.js

## 用户行为的影响

1. 打开网页
2. f5
3. ctrl + f5 `Cache-Control: no-cache / Prama: no-cache`

## 浏览器缓存
