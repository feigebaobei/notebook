# overview
[原文](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/)
esm（ES Module）是js进行了10年标准化的成果。
从2018年以后全部现代浏览器都支持esm。未来还可以把esm生成wasm（WebAssembly）。

# esm解决了什么问题
为解决变量的访问问题。使用更高级的使用作用域解决。直到全局使用域为止。
例如：想使用jquery，则需要先引入jquery插件。而且必须注意引入的顺序。
任意方法都可以获得全局变量。可以任意修改全局变量。

## 模块模式什么进步
有更好的方法管理变量、方法。
在一个模块作用域内共享变量、方法。
还可控制其他模块可以访问哪些变量、方法、类。
可以会成若干小模块独立负责一小部分功能，然后再组装成一个大模块。
模块模式有多种方式处理模块。原来的commonjs已经过时了。现在在ecmascript module更好用。node.js主要使用commonjs，它现在也支持一些esm。现代浏览器已经支持esm了。

# esm如何工作
把多个小模块合成一个大模块。
浏览器、node会从入口获取需要加载的模块。
但是浏览器不知道如何使用模块。它需要平行地把所有模块转换为叫做“模块记录”的数据结构。然后就知道这个文件是做什么的了。
然后模块记录需要转换成模块实例。一个实例包括：代码和状态。
代码是基本指令集。就像一个秘诀。但是你不会知道代码是做什么的。使用代码时需要生材料。
状态就是生材料。状态是运行代码的实际值。所有变量都是内存中相应值的昵称。
我们需要每一个模块的实例。从入口文件加载完模块，就有了模块实例地图了。过程如下：
1. 创建 发现/下载/解析所有文件成为模块记录。
2. 实例 发现这些包的输出值。
3. 运行 使用变量的真实的值去运行代码。
这三个步骤可以异步运行。
在cjs（commonjs）模式下需要加载完成后要实例化再运行。
至少要等待加载完成，所以不是严格的遵守esm。实际上2种方式都会用到。
esm规则说明了如何解析模块记录，如何实例/运行模块。但是没有说首先得到文件。
在特定的环境有特定的加载器（loader）。如：在浏览器下。
loader可以精确控制模块。使用的方法有`ParseModule`/`Module.Instantiate`/`Module.Evaluate`

## construction
在创建阶段会对每个模块执行以下工作：
1. 决定在哪儿下载
2. 下载
3. 解析成为模块记录。

## 发现并下载文件
loader发现并开始下载文件。在html中，一般从`<script src="main.js" type="module">`开发下载。此文件有若干`import`。再从import引入下一个模块。
如`import {count} from './count.js`。
在node.js/browser的环境中运行模块模式会有不同。二者在模块解析算法上不同。
在浏览器中，会根据url下载模块。不会同时生成模块地图。浏览器需要一层一层地解析每个文件，然后绘出它们间的依赖，再然后加载它们的依赖。因此主线程需要等待加载完所有文件，此时有大量的任务在队列中。需要用较长时间去加载文件。
适当地分为几个模块对浏览器更友好。
esm会在evaluation前完成模块地图，因此esm中不使用在模块标识符中使用变量。
实际中仍然会在模块标记符中使用变量，如环境变量等。解决方案是：使用引入静态声明`import('${path}/foo.js')`。结果是创建一个新的模块地图。

## parsing
加载完模块后就是解析模块。根据模块地图生成模块记录。模块记录会代替模块地图。
同一个模块可以被解析为不同格式。
在浏览器中只要使用`type="module"`，则浏览器就知道应该解析为模块。并且可以使用import。
在node中。一般使用`*.mjs`标明该文件需要被视为module处理。处理过程：开启新线程加载完所有依赖，再解析。
结束时会得到一个入口对应若干模块记录。

## instantiation
js引擎会创建模块环境记录。它里面有该模块的所有变量。包括输出变量。
在evaluation之前不能被访问。
按依赖关系倒序实例化出模块地图。
出口与入口在同一个内存位置。当改变了输出值时，可以得到改变后的值。
在cjs中输出一复制后的对象。即：先输出再改变时该对象无法得到改变后的值。

## evaluation
js引擎执行顶层方法去填充内容。
多次执行同一文法是否得到相同的值。
模块地图使用url对应模块。所以一个模块对应一个url。按依赖关系倒序评估。
在循环引用时，若使用到的变量是其他模块的输出值，则分配一个空内存（undefined）使用。然后继续评估，直到顶层。

# esm的状态是什么
已经开始兼容cjs、cjs了。正在进行中。
